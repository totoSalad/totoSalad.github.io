{"pages":[],"posts":[{"title":"react-router 背后的故事","text":"底层实现 —— history 本节内容转载自作者：zhenhua-lee链接：https://juejin.im/post/5b797c52e51d4538db349b05 history 是一个独立的第三方js库，可以用来兼容在不同浏览器、不同环境下对历史记录的管理，拥有统一的API。具体来说里面的history分为三类: 老浏览器的history: 主要通过hash来实现，对应 createHashHistory 高版本浏览器: 通过 html5 里面的 history，对应 createBrowserHistory node 环境下: 主要存储在 memeory 里面，对应 createMemoryHistory （木有什么接触，不扩展介绍） URL 前进 createBrowserHistory: pushState、replaceState createHashHistory: location.hash=***、location.replace() 检测URL回退 createBrowserHistory: popstate createHashHistory: hashchange state 值存储在 sessionStorage 里rr4 的实现 Router 监听 history 的变化，并且通过 state 影响子组件的变化。1234567this.unlisten = props.history.listen(location =&gt; &#123; if (this._isMounted) &#123; this.setState(&#123; location &#125;); &#125; else &#123; this._pendingLocation = location; &#125;&#125;); 路由匹配在之前的版本中，在 Route 中写入的 path，在路由匹配时是独一无二的，而 v4 版本则有了一个包含的关系：如匹配 path=&quot;/users&quot; 的路由会匹配 path=&quot;/&quot; 的路由，在页面中这两个模块会同时进行渲染。 如果只想匹配一个路由的话，则需要 &lt;Switch/&gt; 。v4这个改造与其 router即组件 的思路有一定关系， 多个 match 的组件会对一个 url 进行响应，&lt;Switch/&gt; 就是个用户定制的条件。 在 matchPath 函数中使用了 &quot;path-to-regexp&quot; 来匹配 restful 接口，写法较为优雅。 1234567891011121314151617// const compilePath = (path, options) =&gt; &#123; const keys = []; const regexp = pathToRegexp(path, keys, options); return &#123; regexp, keys &#125;;&#125;const &#123; regexp, keys &#125; = compilePath(path, &#123; end: exact, strict, sensitive&#125;);const match = regexp.exec(pathname); // 正则匹配if (!match) return null;const isExact = pathname === url; // 是否精准匹配 参考资料 React-Router底层原理分析与实现 react-router的实现原理 react-router 4 升级","link":"/2019/04/07/react-router-背后的故事/"},{"title":"浏览器原理","text":"浏览器结构 Process and Thread. thread 是 process 的一部分 可以开启多个 process，process 之间通过 IPC（Inter Process Communication） 交互。 浏览器架构 process 类型 内容 Browser 1. chrome 应用。包含 address bar, bookmarks, back and forward buttons. 2. 还处理Web浏览器的不可见特权部分，例如网络请求和文件访问。 Renderer tab 内容展示 Plugin 浏览器插件，比如 flash GPU 处理其他 process 的 GPU 任务 每个 Tab/iframe 会运行一个独立的 render process。 独立 render process 可以当某个 Tab 崩溃，其他 Tab 正常工作 独立 render process 保证了每个 iframe 访问的数据必须满足 same origin(同源政策) 。 页面跳转 从 browser process 开始，包含 UI thread / Network thread / storage thread 步骤： 输入网址 回车确认 UI thread 初始化请求， network thread 查询 DNS / 建立 TLS 连接。此时 UI thread 使 tab 转圈圈。 这个过程中 network thread 与 UI thread 会相互通信，比如301，network 会让 UI thread 重新请求 接收请求 MIME-TYPE 校验 跨域校验 根据 MIME-TYPE 渲染数据 如果请求是 HTML ，则渲染页面 UI thread 寻找对应的 renderer process 渲染 renderer process 执行渲染 渲染完成 render process 通知 browser process 如果有新的 url 输入，页面需要跳转 browser process 通知 render process 处理 unloaded 事件 service worker service worker 会对 network 做代理，允许用户选择读取 cache 还是发送请求获取新数据。 service worker 是 js 脚本，在 render process 中运行。但是 network thread 存在在 browser process 中，browser process 要如何知晓 render process 中存在 service worker 呢？ 注册 service worker 时，会在 Network thread 中留下引用值。相关链接 renderer process 处理页面渲染 Main thread 会处理大部分内容，包括 parsing / style 计算 / layout 构建 / paint 操作/ js 执行 composition 则在单独的 compositor 执行 parsing 解析 DOM。对错误处理友好。 可以边解析 DOM，边请求 &lt;img/&gt; 等资源 js 会 block parsing &lt;script&gt; 标签添加 async / defer。这样不会阻断主流程&lt;link rel=&quot;preload&quot;&gt; 添加 preload 标志，告诉浏览器你希望这个资源能尽快下载. style 计算 Layout浏览器会构建一个与 DOM 树类似的树，展示 x, y, width, height 信息。伪类元素也会在这个阶段应用。 paint在这个阶段还需计算组件的 order。Layout 树会被遍历产生一个 Paint Record. 以 pipeline 的方式进行更新 js 也在 main thread 中进行，会阻碍渲染 可以将 js 操作颗粒化，可以使用 requestAnimationFrame() / web worker compositing 合成 compositing 则是将 page 分成不同的 layer, 对每个 layer 都进行 raster(光栅化)，然后在 compositor thread 上合成(composition).页面滚动时因为 layer 都已经 raster 完成，只需要合成。 composition 会根据 Layout tree, 构建一棵 layer tree。不是一个Element 一个layer, 具体如下 Stick to Compositor-Only Properties and Manage Layer Count compositing 不在 main thread 上完成，不需要等待 style 计算、js 执行. CSS 对各个阶段的影响https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/ translate 与 opacity 会在compositor thread 中处理，不会影响主线程。 回流(reflows) 影响了 layout，重绘(repaint) 影响了 paint 过程 如何减少回流与重绘：ZXX 回流与重绘 参考文献本文英文原文eliminate-content-repaints-with-the-new-layers-panelhigh-performance-animationsAccelerated Rendering in Chrome","link":"/2019/07/14/浏览器原理/"},{"title":"命名规范","text":"原则：Your code must be easily understandable for humans 通用规范 函数使用动词/动宾/主动宾结构。避免太短、神秘或者大段注释 1234// badfunction inv (user) &#123; /* implementation */ &#125;// goodfunction inviteUser (emailAddress) &#123; /* implementation */ &#125; 名字需要能表明具体功能，不要过于抽象（比如 type / category）。不必担心过长的变量名，但是也不推荐太长的命名(超过50个字符) 12345678let elapsed // badlet daysSinceModification // goodlet type, kind, variant, classification, subcategory // badlet packagingType, AgeGroup // goodfunction addDate(date, month) &#123;// ...&#125; // badfunction addMonthToDate(date, month) &#123;// ... &#125; // good 使用有意义、可读性好的字符，不要增加额外的、不必要的定语 (不推荐匈牙利命名法) 12let nameString //badlet name // good 除了常用简写其他单词不简写，减少人脑处理的时间 12let fName, lName // badlet firstName, lastName // good 1234567891011121314// badvar locations = ['Austin', 'New York', 'San Francisco'];locations.forEach((l) =&gt; &#123; ... // l是什么？ dispatch(l);&#125;);// goodvar locations = ['Austin', 'New York', 'San Francisco'];locations.forEach((location) =&gt; &#123; ... dispatch(location);&#125;); 避免重复描述, 当类/对象名已经有意义时，对其变量进行命名不需要再次重复。 123456789101112// badvar Car = &#123; carMake: 'Honda', carModel: 'Accord', carColor: 'Blue'&#125;;// goodvar Car = &#123; make: 'Honda', model: 'Accord', color: 'Blue'&#125;; 对功能类似的变量名采用统一的命名风格 123456// badgetUserInfo()getClientData()getCustomerRecord()//goodgetUser() 命名约定(变量、函数、类) 变量，名词，使用小驼峰命名 1let loadingModules // good 常量，名词，全部使用大写，多个单词可以用_分割 1let LOADINGMODULES // good 类名，名词，使用大驼峰命名 1class Engine &#123;&#125; // good 函数名，动词、动宾短语，使用小驼峰命名 1let hasCommands = false // good Promise 对象，动宾短语的进行时 1let loadingData = ajax.get('url'); // good 私有属性、变量和方法以下划线 _ 开头 1let _loadingModules // good 函数命名拥有固定前缀 前缀 作用 返回值 can 判断是否可执行某个动作 ( 权限 ) 函数返回一个布尔值。true：可执行；false：不可执行 has 判断是否含有某个值 函数返回一个布尔值。true：含有此值；false：不含有此值 is 判断是否为某个值 函数返回一个布尔值。true：为某个值；false：不为某个值 get 获取某个值 函数返回一个非布尔值 set 设置某个值 无返回值、返回是否设置成功或者返回链式对象 复数变量加上s 12let userList = [] // badlet users = [] // good 文件规范（建议）文件名规范 文件导出的内容与文件名保持一致，所见即所得 React 组件文件名： (取自 airbnb ) 文件命名采用帕斯卡命名法(大驼峰) 1234// badreservation-card.js// goodReservationCard.js 文件名与导出的组件名保持一致 高阶组件文件名： (取自 airbnb ) 文件命名：with + 功能(名词) 1234//bad leaveHookHoc.js//goodwithLeaveHook.js markdown 等说明性文件名 文件命名采用全大写，多个单词使用 _ 分割1234// badreadme.md// goodREADME.md 函数文件名： 文件名与导出的函数名保持一致1234// badescape-test-for-browser.js// goodescapeTextForBrowser.js 文件夹名规范 文件夹名要使用小写英文字符，使用 - 来区分单词 参考文献clean code #强烈推荐15个最佳实践通用规范vue 开发规范前端开发规范程序命名的一些提示","link":"/2018/09/22/命名规范/"}],"tags":[{"name":"规范","slug":"规范","link":"/tags/规范/"}],"categories":[{"name":"规范","slug":"规范","link":"/categories/规范/"}]}