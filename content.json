{"pages":[],"posts":[{"title":"react-router 背后的故事","text":"底层实现 —— history 本节内容转载自作者：zhenhua-lee链接：https://juejin.im/post/5b797c52e51d4538db349b05 history 是一个独立的第三方js库，可以用来兼容在不同浏览器、不同环境下对历史记录的管理，拥有统一的API。具体来说里面的history分为三类: 老浏览器的history: 主要通过hash来实现，对应 createHashHistory 高版本浏览器: 通过 html5 里面的 history，对应 createBrowserHistory node 环境下: 主要存储在 memeory 里面，对应 createMemoryHistory （木有什么接触，不扩展介绍） URL 前进 createBrowserHistory: pushState、replaceState createHashHistory: location.hash=***、location.replace() 检测URL回退 createBrowserHistory: popstate createHashHistory: hashchange state 值存储在 sessionStorage 里rr4 的实现 Router 监听 history 的变化，并且通过 state 影响子组件的变化。1234567this.unlisten = props.history.listen(location =&gt; &#123; if (this._isMounted) &#123; this.setState(&#123; location &#125;); &#125; else &#123; this._pendingLocation = location; &#125;&#125;); 路由匹配在之前的版本中，在 Route 中写入的 path，在路由匹配时是独一无二的，而 v4 版本则有了一个包含的关系：如匹配 path=&quot;/users&quot; 的路由会匹配 path=&quot;/&quot; 的路由，在页面中这两个模块会同时进行渲染。 如果只想匹配一个路由的话，则需要 &lt;Switch/&gt; 。v4这个改造与其 router即组件 的思路有一定关系， 多个 match 的组件会对一个 url 进行响应，&lt;Switch/&gt; 就是个用户定制的条件。 在 matchPath 函数中使用了 &quot;path-to-regexp&quot; 来匹配 restful 接口，写法较为优雅。 1234567891011121314151617// const compilePath = (path, options) =&gt; &#123; const keys = []; const regexp = pathToRegexp(path, keys, options); return &#123; regexp, keys &#125;;&#125;const &#123; regexp, keys &#125; = compilePath(path, &#123; end: exact, strict, sensitive&#125;);const match = regexp.exec(pathname); // 正则匹配if (!match) return null;const isExact = pathname === url; // 是否精准匹配 参考资料 React-Router底层原理分析与实现 react-router的实现原理 react-router 4 升级","link":"/2019/04/07/react-router-背后的故事/"},{"title":"命名规范","text":"原则：Your code must be easily understandable for humans 通用规范 函数使用动词/动宾/主动宾结构。避免太短、神秘或者大段注释 1234// badfunction inv (user) &#123; /* implementation */ &#125;// goodfunction inviteUser (emailAddress) &#123; /* implementation */ &#125; 名字需要能表明具体功能，不要过于抽象（比如 type / category）。不必担心过长的变量名，但是也不推荐太长的命名(超过50个字符) 12345678let elapsed // badlet daysSinceModification // goodlet type, kind, variant, classification, subcategory // badlet packagingType, AgeGroup // goodfunction addDate(date, month) &#123;// ...&#125; // badfunction addMonthToDate(date, month) &#123;// ... &#125; // good 使用有意义、可读性好的字符，不要增加额外的、不必要的定语 (不推荐匈牙利命名法) 12let nameString //badlet name // good 除了常用简写其他单词不简写，减少人脑处理的时间 12let fName, lName // badlet firstName, lastName // good 1234567891011121314// badvar locations = ['Austin', 'New York', 'San Francisco'];locations.forEach((l) =&gt; &#123; ... // l是什么？ dispatch(l);&#125;);// goodvar locations = ['Austin', 'New York', 'San Francisco'];locations.forEach((location) =&gt; &#123; ... dispatch(location);&#125;); 避免重复描述, 当类/对象名已经有意义时，对其变量进行命名不需要再次重复。 123456789101112// badvar Car = &#123; carMake: 'Honda', carModel: 'Accord', carColor: 'Blue'&#125;;// goodvar Car = &#123; make: 'Honda', model: 'Accord', color: 'Blue'&#125;; 对功能类似的变量名采用统一的命名风格 123456// badgetUserInfo()getClientData()getCustomerRecord()//goodgetUser() 命名约定(变量、函数、类) 变量，名词，使用小驼峰命名 1let loadingModules // good 常量，名词，全部使用大写，多个单词可以用_分割 1let LOADINGMODULES // good 类名，名词，使用大驼峰命名 1class Engine &#123;&#125; // good 函数名，动词、动宾短语，使用小驼峰命名 1let hasCommands = false // good Promise 对象，动宾短语的进行时 1let loadingData = ajax.get('url'); // good 私有属性、变量和方法以下划线 _ 开头 1let _loadingModules // good 函数命名拥有固定前缀 前缀 作用 返回值 can 判断是否可执行某个动作 ( 权限 ) 函数返回一个布尔值。true：可执行；false：不可执行 has 判断是否含有某个值 函数返回一个布尔值。true：含有此值；false：不含有此值 is 判断是否为某个值 函数返回一个布尔值。true：为某个值；false：不为某个值 get 获取某个值 函数返回一个非布尔值 set 设置某个值 无返回值、返回是否设置成功或者返回链式对象 复数变量加上s 12let userList = [] // badlet users = [] // good 文件规范（建议）文件名规范 文件导出的内容与文件名保持一致，所见即所得 React 组件文件名： (取自 airbnb ) 文件命名采用帕斯卡命名法(大驼峰) 1234// badreservation-card.js// goodReservationCard.js 文件名与导出的组件名保持一致 高阶组件文件名： (取自 airbnb ) 文件命名：with + 功能(名词) 1234//bad leaveHookHoc.js//goodwithLeaveHook.js markdown 等说明性文件名 文件命名采用全大写，多个单词使用 _ 分割1234// badreadme.md// goodREADME.md 函数文件名： 文件名与导出的函数名保持一致1234// badescape-test-for-browser.js// goodescapeTextForBrowser.js 文件夹名规范 文件夹名要使用小写英文字符，使用 - 来区分单词 参考文献clean code #强烈推荐15个最佳实践通用规范vue 开发规范前端开发规范程序命名的一些提示","link":"/2018/09/22/命名规范/"}],"tags":[{"name":"规范","slug":"规范","link":"/tags/规范/"}],"categories":[{"name":"规范","slug":"规范","link":"/categories/规范/"}]}