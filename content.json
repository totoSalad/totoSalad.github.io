{"pages":[],"posts":[{"title":"react-router 背后的故事","text":"底层实现 —— history 本节内容转载自作者：zhenhua-lee链接：https://juejin.im/post/5b797c52e51d4538db349b05 history 是一个独立的第三方js库，可以用来兼容在不同浏览器、不同环境下对历史记录的管理，拥有统一的API。具体来说里面的history分为三类: 老浏览器的history: 主要通过hash来实现，对应 createHashHistory 高版本浏览器: 通过 html5 里面的 history，对应 createBrowserHistory node 环境下: 主要存储在 memeory 里面，对应 createMemoryHistory （木有什么接触，不扩展介绍） URL 前进 createBrowserHistory: pushState、replaceState createHashHistory: location.hash=***、location.replace() 检测URL回退 createBrowserHistory: popstate createHashHistory: hashchange state 值存储在 sessionStorage 里rr4 的实现 Router 监听 history 的变化，并且通过 state 影响子组件的变化。1234567this.unlisten = props.history.listen(location =&gt; &#123; if (this._isMounted) &#123; this.setState(&#123; location &#125;); &#125; else &#123; this._pendingLocation = location; &#125;&#125;); 路由匹配在之前的版本中，在 Route 中写入的 path，在路由匹配时是独一无二的，而 v4 版本则有了一个包含的关系：如匹配 path=&quot;/users&quot; 的路由会匹配 path=&quot;/&quot; 的路由，在页面中这两个模块会同时进行渲染。 如果只想匹配一个路由的话，则需要 &lt;Switch/&gt; 。v4这个改造与其 router即组件 的思路有一定关系， 多个 match 的组件会对一个 url 进行响应，&lt;Switch/&gt; 就是个用户定制的条件。 在 matchPath 函数中使用了 &quot;path-to-regexp&quot; 来匹配 restful 接口，写法较为优雅。 1234567891011121314151617// const compilePath = (path, options) =&gt; &#123; const keys = []; const regexp = pathToRegexp(path, keys, options); return &#123; regexp, keys &#125;;&#125;const &#123; regexp, keys &#125; = compilePath(path, &#123; end: exact, strict, sensitive&#125;);const match = regexp.exec(pathname); // 正则匹配if (!match) return null;const isExact = pathname === url; // 是否精准匹配 参考资料 React-Router底层原理分析与实现 react-router的实现原理 react-router 4 升级","link":"/2019/04/07/react-router-背后的故事/"},{"title":"命名规范","text":"原则：Your code must be easily understandable for humans 通用规范 函数使用动词/动宾/主动宾结构。避免太短、神秘或者大段注释 1234// badfunction inv (user) &#123; /* implementation */ &#125;// goodfunction inviteUser (emailAddress) &#123; /* implementation */ &#125; 名字需要能表明具体功能，不要过于抽象（比如 type / category）。不必担心过长的变量名，但是也不推荐太长的命名(超过50个字符) 12345678let elapsed // badlet daysSinceModification // goodlet type, kind, variant, classification, subcategory // badlet packagingType, AgeGroup // goodfunction addDate(date, month) &#123;// ...&#125; // badfunction addMonthToDate(date, month) &#123;// ... &#125; // good 使用有意义、可读性好的字符，不要增加额外的、不必要的定语 (不推荐匈牙利命名法) 12let nameString //badlet name // good 除了常用简写其他单词不简写，减少人脑处理的时间 12let fName, lName // badlet firstName, lastName // good 1234567891011121314// badvar locations = ['Austin', 'New York', 'San Francisco'];locations.forEach((l) =&gt; &#123; ... // l是什么？ dispatch(l);&#125;);// goodvar locations = ['Austin', 'New York', 'San Francisco'];locations.forEach((location) =&gt; &#123; ... dispatch(location);&#125;); 避免重复描述, 当类/对象名已经有意义时，对其变量进行命名不需要再次重复。 123456789101112// badvar Car = &#123; carMake: 'Honda', carModel: 'Accord', carColor: 'Blue'&#125;;// goodvar Car = &#123; make: 'Honda', model: 'Accord', color: 'Blue'&#125;; 对功能类似的变量名采用统一的命名风格 123456// badgetUserInfo()getClientData()getCustomerRecord()//goodgetUser() 命名约定(变量、函数、类) 变量，名词，使用小驼峰命名 1let loadingModules // good 常量，名词，全部使用大写，多个单词可以用_分割 1let LOADINGMODULES // good 类名，名词，使用大驼峰命名 1class Engine &#123;&#125; // good 函数名，动词、动宾短语，使用小驼峰命名 1let hasCommands = false // good Promise 对象，动宾短语的进行时 1let loadingData = ajax.get('url'); // good 私有属性、变量和方法以下划线 _ 开头 1let _loadingModules // good 函数命名拥有固定前缀 前缀 作用 返回值 can 判断是否可执行某个动作 ( 权限 ) 函数返回一个布尔值。true：可执行；false：不可执行 has 判断是否含有某个值 函数返回一个布尔值。true：含有此值；false：不含有此值 is 判断是否为某个值 函数返回一个布尔值。true：为某个值；false：不为某个值 get 获取某个值 函数返回一个非布尔值 set 设置某个值 无返回值、返回是否设置成功或者返回链式对象 复数变量加上s 12let userList = [] // badlet users = [] // good 文件规范（建议）文件名规范 文件导出的内容与文件名保持一致，所见即所得 React 组件文件名： (取自 airbnb ) 文件命名采用帕斯卡命名法(大驼峰) 1234// badreservation-card.js// goodReservationCard.js 文件名与导出的组件名保持一致 高阶组件文件名： (取自 airbnb ) 文件命名：with + 功能(名词) 1234//bad leaveHookHoc.js//goodwithLeaveHook.js markdown 等说明性文件名 文件命名采用全大写，多个单词使用 _ 分割1234// badreadme.md// goodREADME.md 函数文件名： 文件名与导出的函数名保持一致1234// badescape-test-for-browser.js// goodescapeTextForBrowser.js 文件夹名规范 文件夹名要使用小写英文字符，使用 - 来区分单词 参考文献clean code #强烈推荐15个最佳实践通用规范vue 开发规范前端开发规范程序命名的一些提示","link":"/2018/09/22/命名规范/"},{"title":"浏览器原理","text":"浏览器结构 Process and Thread. thread 是 process 的一部分 可以开启多个 process，process 之间通过 IPC（Inter Process Communication） 交互。 浏览器架构 process 类型 内容 Browser 1. chrome 应用。包含 address bar, bookmarks, back and forward buttons. 2. 还处理Web浏览器的不可见特权部分，例如网络请求和文件访问。 Renderer tab 内容展示 Plugin 浏览器插件，比如 flash GPU 处理其他 process 的 GPU 任务 每个 Tab/iframe 会运行一个独立的 render process。 独立 render process 可以当某个 Tab 崩溃，其他 Tab 正常工作 独立 render process 保证了每个 iframe 访问的数据必须满足 same origin(同源政策) 。 页面跳转 从 browser process 开始，包含 UI thread / Network thread / storage thread 步骤： 输入网址 回车确认 UI thread 初始化请求， network thread 查询 DNS / 建立 TLS 连接。此时 UI thread 使 tab 转圈圈。 这个过程中 network thread 与 UI thread 会相互通信，比如301，network 会让 UI thread 重新请求 接收请求 MIME-TYPE 校验 跨域校验 根据 MIME-TYPE 渲染数据 如果请求是 HTML ，则渲染页面 UI thread 寻找对应的 renderer process 渲染 renderer process 执行渲染 渲染完成 render process 通知 browser process 如果有新的 url 输入，页面需要跳转 browser process 通知 render process 处理 unloaded 事件 service worker service worker 会对 network 做代理，允许用户选择读取 cache 还是发送请求获取新数据。 service worker 是 js 脚本，在 render process 中运行。但是 network thread 存在在 browser process 中，browser process 要如何知晓 render process 中存在 service worker 呢？ 注册 service worker 时，会在 Network thread 中留下引用值。相关链接 renderer process 处理页面渲染 Main thread 会处理大部分内容，包括 parsing / style 计算 / layout 构建 / paint 操作/ js 执行 composition 则在单独的 compositor 执行 parsing 解析 DOM。对错误处理友好。 可以边解析 DOM，边请求 &lt;img/&gt; 等资源 js 会 block parsing &lt;script&gt; 标签添加 async / defer。这样不会阻断主流程&lt;link rel=&quot;preload&quot;&gt; 添加 preload 标志，告诉浏览器你希望这个资源能尽快下载. style 计算 Layout浏览器会构建一个与 DOM 树类似的树，展示 x, y, width, height 信息。伪类元素也会在这个阶段应用。 paint在这个阶段还需计算组件的 order。Layout 树会被遍历产生一个 Paint Record. 以 pipeline 的方式进行更新 js 也在 main thread 中进行，会阻碍渲染 可以将 js 操作颗粒化，可以使用 requestAnimationFrame() / web worker compositing 合成 compositing 则是将 page 分成不同的 layer, 对每个 layer 都进行 raster(光栅化)，然后在 compositor thread 上合成(composition).页面滚动时因为 layer 都已经 raster 完成，只需要合成。 composition 会根据 Layout tree, 构建一棵 layer tree。不是一个Element 一个layer, 具体如下 Stick to Compositor-Only Properties and Manage Layer Count compositing 不在 main thread 上完成，不需要等待 style 计算、js 执行. CSS 对各个阶段的影响https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/ translate 与 opacity 会在compositor thread 中处理，不会影响主线程。 回流(reflows) 影响了 layout，重绘(repaint) 影响了 paint 过程 如何减少回流与重绘：ZXX 回流与重绘 参考文献本文英文原文eliminate-content-repaints-with-the-new-layers-panelhigh-performance-animationsAccelerated Rendering in Chrome","link":"/2019/07/14/浏览器原理/"},{"title":"响应式编程","text":"什么是响应式编程 reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change.—- wikipedia 反应式编程是与数据流和传播变化有关的编程模式。目前市面比较流行的库有 backbone.js ， rxjs 喵喵喵？听着似乎与泛滥的 MV* 并无区别。 André Staltz 浏览了很多关于 响应式编程 的书籍与和实践之后，给出了以下两个特征。 anything can be a stream。 丰富的处理流函数 anything can be a streamasynchronous event stream 在通用场景中是可以通过回调处理副作用的事件流，比如 onClick 等 dom 事件，类似发布订阅自定义事件。响应式编程中可以发布 数据, 用户输入, 属性，任何操作和数据都可以是 event stream. 1234567891011const observable = Rx.observable.create(observer =&gt; &#123; console.log('start executing'); observer.next('hello world')&#125;);observable.subscribe(value =&gt; &#123; console.log(value)&#125;);// 输出: // start executing // hello world stream 是啥？Stream 是一组执行中的事件，可以分发三种内容：value / error / “completed” 标志。分发的内容可以被监听 (subscribe) ，类似发布订阅的模式。 demo: stream 状态以 click button 为例: ASCII 展示: 123456--a---b-c---d---X---|-&gt;a, b, c, d are emitted valuesX is an error| is the &apos;completed&apos; signal---&gt; is the timeline demo: stream 监听通过 subscribe 监听事件。123const observable = Rx.observable.fromEvent(button, &apos;click&apos;) .map(event =&gt; event.clientX);observable.subscribe(value =&gt; &#123;console.log(value)&#125;); 丰富的处理流函数 merge: 合并多个 stream buffer：缓存 stream，直到 stream emit filter : 类似数组的 filter，返回一组新 stream map : 类似数组的 map，返回一组新 stream 假设我们希望得到 “double click” 流，并且允许短时的多次点击也等同于 “double click”。 1234var singleClickStream = clickStream .buffer(function() &#123; return clickStream.throttle(250); &#125;) .map(function(list) &#123; return list.length; &#125;) .filter(function(x) &#123; return x === 1; &#125;); why use it?与 redux，mobx 相比 便于处理多个异步事件，相比 Promise 可以有多个返回值，以及可以进行更复杂的处理。 事件（异步、同步）处理标准化。 对应中后台的场景： 控制多个异步行为，尤其是异步行为存在依赖关系 dashboard 在不同情况下需要更新不同的组件 rxjsrxjs 是最流行的响应式库之一，我们以之为例来展示响应式编程是如何应用的。 Observable可观察对象：可观察对象是数据流的源头，可以来自事件，网络，也可以自定义数据流。 Observer观察者：通过订阅可观察对象，即可获得观察者，观察者拦截处理数据流，可以视为数据流的终点 Operator操作符：操作符主要用于数据流的转换操作 Subject主题：集Observable和Observer的特点于一身，还可以用于广播事件流 Sheduler调度者：控制事件流的并发 show me some code!下图是一个常见的搜索框，可以选择排序方式：热度(popularity) / 日期(date) 。如果搜索字段发生变更，或者排序方式变化则重新发起请求。 完整代码 react + 非 rxjs我们按照 Contianer / Present 组件的方式构建代码。Contianer 组件把搜索相关的字段（query / subject）都放在 state 中保存，同时暴露了修改 state 方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344const SmartWrapper = Component =&gt; &#123; return class extends React.Component &#123; this.state = &#123; query: \"react\", subject: SUBJECT.POPULARITY, stories: [] &#125;; onSelectSubject = subject =&gt; &#123; this.setState(&#123; subject &#125;); &#125;; onChangeQuery = query =&gt; &#123; if (query) &#123; this.setState(&#123; query &#125;); &#125; &#125;; // debounce 操作 debouncdFetch = debounce((&#123; subject, query &#125;) =&gt; &#123; return mockData(`http://hn.algolia.com/api/v1/$&#123;subject&#125;?query=$&#123;query&#125;`) .then(result =&gt; result.data.hits) .then(stories =&gt; this.setState(&#123; stories &#125;)); &#125;, 1000); componentDidUpdate(prevProps, prevState) &#123; const &#123; query: preQuery, subject: preSubject &#125; = prevState; const &#123; query, subject &#125; = this.state; if (preQuery !== query || preSubject !== subject) &#123; this.debouncdFetch(&#123; query, subject &#125;); &#125; &#125; render() &#123; const triggers = &#123; onSelectSubject: this.onSelectSubject, onChangeQuery: this.onChangeQuery &#125;; return &lt;Component &#123;...this.props&#125; &#123;...this.state&#125; &#123;...triggers&#125; /&gt;; &#125; &#125;;&#125;;export default SmartWrapper(App); react + rxjsObservable 观察内容rxjs Observable 实质是 stream，我们可以把数据当做一种 stream . BehaviorSubject 是一种 Oberservale, 即当前值就是观察项。如果值发生变化则会通知订阅者。 123import &#123;BehaviorSubject&#125; from &apos;rxjs&apos; const query$ = new BehaviorSubject(&quot;react&quot;); // 搜索内容const subject$ = new BehaviorSubject(SUBJECT.POPULARITY); // 排序方式 功能上 query$ 或 subject$ 发生变化会触发 fetch 行为。我们也可以把query$ 和 subject$ 的变化合成一个 Observable, Observable 的返回异步行为(fetch stories） 1234567891011121314// 因为// 1. 输入时不搜索(debounce)// 2. text为空时不搜索const queryForFetch$ = query$.pipe( debounce(() =&gt; timer(1000)), filter(query =&gt; query !== \"\"));const fetch$ = combineLatest(subject$, queryForFetch$).pipe( flatMap(([subject, query]) =&gt; mockData(`http://hn.algolia.com/api/v1/$&#123;subject&#125;?query=$&#123;query&#125;`) ), map(result =&gt; result.data.hits)); Observable 变化函数 triggerObservable.next 可以发送值给观察者。 12const onSelectSubject = subject =&gt; subject$.next(subject),const onChangeQuery = value =&gt; query$.next(value) react 订阅 Observablerxjs subscribe 可以订阅 Observable 的变化，进行副作用操作。 与非 rxjs 的实现相同，我们会把 Observable 都在 state 中储存。如果 Observable 发生变化需要触发 setState, 通知 react 发生更新。因为这部分行为具有一定的通用性，所以我们把它放在 HOC 中处理。 1234567891011121314151617181920212223242526272829// withObservableStream.jsexport default (observable, triggers, initialState) =&gt; Component =&gt; &#123; return class extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; ...initialState, &#125;; &#125; componentDidMount() &#123; this.subscription = observable.subscribe(newState =&gt; this.setState(&#123; ...newState &#125;), ); &#125; componentWillUnmount() &#123; this.subscription.unsubscribe(); &#125; render() &#123; return ( &lt;Component &#123;...this.props&#125; &#123;...this.state&#125; &#123;...triggers&#125; /&gt; ); &#125; &#125;;&#125;; 最终代码12345678910111213141516171819202122232425262728293031323334const query$ = new BehaviorSubject(\"react\");const subject$ = new BehaviorSubject(SUBJECT.POPULARITY);// 1. 输入时不搜索(debounce)// 2. text为空时不搜索const queryForFetch$ = query$.pipe( debounce(() =&gt; timer(1000)), filter(query =&gt; query !== \"\"));// combineLatest：合并两个流为新流，并取两个流最近值const fetch$ = combineLatest(subject$, queryForFetch$).pipe( flatMap(([subject, query]) =&gt; mockData(`http://hn.algolia.com/api/v1/$&#123;subject&#125;?query=$&#123;query&#125;`) ), map(result =&gt; result.data.hits));export default withObservableStream( combineLatest(subject$, query$, fetch$, (subject, query, stories) =&gt; (&#123; subject, query, stories &#125;)), &#123; onSelectSubject: subject =&gt; subject$.next(subject), onChangeQuery: value =&gt; query$.next(value) &#125;, &#123; query: \"react\", subject: SUBJECT.POPULARITY, stories: [] &#125;)(App); 总结这两段代码相比 rxjs 版的业务逻辑更加精简，清晰，可以很好地与 UI 分离。但是 rxjs 复杂度更高，理解与学习成本高。rxjs 可以与 state 一起管理数据，除此之外还可以与 redux 一起配合（redux-observable）在 Redux 中使用到 RxJS 所提供的函数响应式编程（FRP）的能力。 后续Rxjs 有以下两个优点1、 Observale 的形态是流，扩展方便。2、异步事件标准化 因为这两个优点，rxjs 十分适用于需要一定扩展度的公共组件。会尝试使用 rxjs 在 papaya-ui 中，解决固定场景的数据管理问题，比如 Dashboard 或者 search box + table 的场景。 资料https://gist.github.com/staltz/868e7e9bc2a7b8c1f754https://zhuanlan.zhihu.com/p/31623736https://www.robinwieruch.de/react-rxjs-state-management-tutorialhttp://www.alloyteam.com/2016/12/learn-rxjs/https://juejin.im/post/5b798501f265da43473130a1","link":"/2019/11/28/响应式编程/"},{"title":"如何优雅使用 hooks","text":"使用了 hooks 一小段时间，时常有非预期的bug，还要小心翼翼担心重复渲染导致的性能瓶颈，令人头发稀少，十分抓狂。本文从函数式组件、性能问题等角度解除大家的疑惑，放心玩耍~ 我们不一样！函数式组件与 class 组件首先不得不提 hooks 依附的函数式组件。两者有什么不同呢？class 组件具体更多的feature，比如生命周期、state。function 组件因为少了这些生命周期会渲染地更快。然而这些都不是最大的区别，Dan 认为是: Function components capture the rendered values. 直接翻译是 function 捕捉的是渲染的值，说着抽象，show me some code。 1234567891011121314// function 实现的 ProfilePagefunction ProfilePage(props) &#123; const showMessage = () =&gt; &#123; alert('Followed ' + props.user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return ( &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt; );&#125; 1234567891011121314// class 实现的 ProfilePageclass ProfilePage extends React.Component &#123; showMessage = () =&gt; &#123; alert('Followed ' + this.props.user); &#125;; handleClick = () =&gt; &#123; setTimeout(this.showMessage, 3000); &#125;; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;zai 两个组件似乎只是同一功能的两种实现，看似没有区别，live demo 执行操作： 选择 profile 为 dan 点击 follow (function) / follow (class) 修改 profile 为 sophie 两个组件 alter 的内容竟然不一致！function 的行为是正确的，user 依旧是点击时的 Dan。而 class 组件因为 this.props 是动态变化的，所以获得了更新后的值。 如果希望 class 的行为表现一致的话，则应该按以下的方式实现: 12345678910111213141516171819// 行为一致的 class 组件实现class ProfilePage extends React.Component &#123; render() &#123; // Capture the props! const props = this.props; // Note: we are *inside render*. // These aren't class methods. const showMessage = () =&gt; &#123; alert('Followed ' + props.user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125; 现在我们可以很好的理解 function 捕捉的是渲染的值 了吧~ 如果希望 function 组件获取最新的 state，不与具体渲染有关。我们也可以借助 useRef hooks 实现类似 instance field 的效果 1234567891011121314151617181920// function 实现的 ProfilePagefunction ProfilePage(props) &#123; const user = useRef(props.user) useEffect(() =&gt; &#123; user.current = props.user &#125;) const showMessage = () =&gt; &#123; alert('Followed ' + user.current); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return ( &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt; );&#125; 令人恐惧？函数式组件的重复渲染函数组件还有一个特别让人紧张的特性，组件 update 阶段时函数组件会重新执行，函数组件内部的变量、方法均会重新生成。 Impedance Mismatch （阻碍不匹配）问题处理setInterval API 在 react 中使用属于一个典型的阻碍不匹配。两者在描述状态变化方便有很大的差异。 react 渲染结果与变化的状态保持一致 12// 描述每次渲染return &lt;h1&gt;&#123;delay&#125;&lt;/h1&gt; setInterval 无法同步状态变化，只能清除重建 12// delay 发生变化setInterval(tick, delay); 所以在 react 中使用 setInterval，并且 delay 发生变化。class 的处理非常复杂，需要手动反复挂载 setInterval 事件。完整对比，请点击 而 hooks 因为函数式组件会重新执行，则不需要手动挂载。 1234567891011121314151617181920212223242526function Counter(props) &#123; const [count, setCount] = useState(0); const savedCallback = useRef(); // 每次更新组件，callback 重新生成，与不同的 count 绑定。 function callback() &#123; setCount(count + 1); &#125; // 每次更新时同步 callback 函数，避免 stale state 问题。 useEffect(() =&gt; &#123; savedCallback.current = callback; &#125;); // delay 更新时，更新 setInterval 函数。 useEffect(() =&gt; &#123; function tick() &#123; savedCallback.current(); &#125; let id = setInterval(tick, 1000); return () =&gt; clearInterval(id); // componentDidUpdate 与 unmount 的情况下销毁现有 interval. &#125;, [props.delay]); return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125; 值得注意的是每次组件更新时 callback 需要重新挂载。因为 callback 函数与 count 之间形成了闭包关系，每次组件更新时 callback 都会重新生成，与最新的 count 绑定。 在 setInterval 的场景下，因为 hooks 的组件更新则函数更新的行为，不需要做手动同步，更加自然。 直面性能恐惧让我们来面对我们最担心的性能问题，最大的疑惑主要集中在两方面： 在渲染时创建函数会影响性能？ 在现代浏览器中，闭包和类的原始性能只有在极端场景下才会有明显的差别。反倒因为 hooks 基于 function component 减少了很多 class component 的开支。 子组件无关渲染如何解决？ 如下例子：handleClick 函数表现的类似 class 组件中的 inline 函数。 如果 handleClick 属性发生变化，子组件 &lt;Button&gt; 即便使用了 React.memo （类似 pureComponent）也得被迫更新，最终整个组件树发生了更新。 1234567891011function App() &#123; const [isOn, setIsOn] = useState(false); const handleClick = () =&gt; setIsOn(!isOn); // 每次渲染，重新生成 handleClick return ( &lt;div className=\"App\"&gt; &lt;h1&gt;&#123;isOn ? \"On\" : \"Off\"&#125;&lt;/h1&gt; &lt;Button handleClick=&#123;handleClick&#125; /&gt; // button 因为属性不一样一定会重新渲染 &lt;/div&gt; );&#125; 如何解决 useCallback 与 React.memouseCallback 指定 depends，可以避免多余渲染。 12const handleClick = callBack(() =&gt; setIsOn(isOn =&gt; !isOn), []); // 组件 rerender 时，函数不会再次生成 但是对所有的函数使用 useCallback 记住旧值，绝对不是一个最佳实践。因为 useCallback 本质是一个 memorized 函数，空间换效率，使用过多反倒会造成内存泄漏等问题。其次如果 useCallback 有遗漏的依赖项会出现 stale data 的情况。会在下一章详细介绍。 useReduceruseReducer 产生的 dispatch 不会发生变化，方便处理深层更新。相关 issue 123456789101112const TodosDispatch = React.createContext(null);function TodosApp() &#123; // 提示：`dispatch` 不会在重新渲染之间变化 const [todos, dispatch] = useReducer(todosReducer); return ( &lt;TodosDispatch.Provider value=&#123;dispatch&#125;&gt; &lt;DeepTree todos=&#123;todos&#125; /&gt; &lt;/TodosDispatch.Provider&gt; );&#125; 如果对性能还有疑问请看 react hooks faq hooks 使用instance field在函数式组件中所有的变量、方法都会在更新时重新赋值，如果期望实现 this (instance field)，useRef 可以实现。 useRef 也可以处理 element ref 的情况。 123456789101112131415// 将 count 绑定在 this 上function AutoCount(props) &#123; const count = useRef(0) // 无需更新的 increase 函数，但是 count 值是最新的 const increase = callback(() =&gt; &#123; count.current = count.current++ &#125;, []) return ( &lt;p&gt;&#123;count&#125;&lt;/p&gt; &lt;Button onClick=&#123;increase&#125;&gt;increaee&lt;/Button&gt; );&#125; stale closures 陷阱useCallback / useMemo 不是万能的，使用时很容易与 stale state (旧state) 绑定，我们称之为 stale closures 陷阱。 useCallback 内部会形成闭包，如果依赖项（第二个参数）不更新， useCallback 的闭包也不会更新，最终函数可能执行永远得不到我们期望的结果。 12345const [isOn, setIsOn] = useState(false);// 错误写法！// 因为 dependence 是 [], 组件 rerender 时，callback 函数不会更新// 闭包不更新，isOn 也永远是 falseconst handleClick = callBack(() =&gt; setIsOn(!isOn), []); 可以把闭包值作为 callback 依赖项，在需要时更新闭包。 12// 正确写法 1const handleClick = callBack(() =&gt; setIsOn(!isOn), [isOn]); 也可以利用 useState 的另一种用法，避开使用闭包值。 12// 正确写法 2const handleClick = callBack(() =&gt; setIsOn(isOn =&gt; !isOn), []); eslint-plugin-react-hooks 会校验 useCallback / useEffect 的 dependence https://github.com/facebook/react/issues/14920 其他注意点 const [arr, setArr] = useState() 的 setArr 需要返回一个全新的数组否则组件不会发生更新，应该是 hooks 内部做了优化会做一层浅比较。 使用 useReducer 时，reducer 不能放在自定义 hooks 内部，否则 action 会触发多次.相关segmentfault 错误写法 1234567891011import &#123; useReducer &#125; from &quot;react&quot;;export function useApiCallReducer() &#123; // 因为放在函数内部，useApiCallReducer 执行时 reducer 就会更新 function reducer(state, action) &#123; switch (action.type) &#123; ... &#125; &#125; return useReducer(reducer, initialState);&#125; 正确写法 12345678import &#123; useReducer &#125; from &quot;react&quot;;// 放在函数外部，reducer 保持不变function reducer(state, action) &#123; switch (action.type) &#123; ... &#125;&#125; 总结react hooks 在 react 内部实现了组件逻辑复用，避免了相关逻辑被生命周期割裂的情况。但是 hooks 依附函数式组件，更新方式与我们常用的 class 组件不一样。我们可以不需要担心函数式组件更新时需要重新初始化函数，会影响性能。在必要时可以采用 useCallback + React.memo / useReducer。但是还是那句老话，过早优化是万恶之源。同时 hooks 也带来了新的问题，instance 使用 、stale data 、除此之外 hooks 内部做了很多所谓的优化，导致了在实践中有很多坑。 其他业界目前木有 hooks 最佳实践，本文不敢夸口最佳实践，只是给出 hooks 使用的注意点，希望能帮助大家优雅使用 hooks ~ 在使用中遇到问题可以在 相关链接 记录。 资料 how-are-function-components-different-from-classes 如何錯誤地使用-react-hooks-usecallback-來保存相同的-function-instance 阻碍不匹配","link":"/2019/11/28/如何优雅使用-hooks/"}],"tags":[{"name":"规范","slug":"规范","link":"/tags/规范/"},{"name":"响应式编程 rxjs","slug":"响应式编程-rxjs","link":"/tags/响应式编程-rxjs/"},{"name":"hooks","slug":"hooks","link":"/tags/hooks/"}],"categories":[{"name":"规范","slug":"规范","link":"/categories/规范/"}]}